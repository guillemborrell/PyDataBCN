#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrartcl
\begin_preamble
\DeclareRobustCommand{\bitcoin}{{%
  \normalfont\sffamily
   \raisebox{-.05ex}{\makebox[.1\width][l]{-\kern-.2em-}}B%
}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
How to manage complexity in distributed systems
\end_layout

\begin_layout Author
Guillem Borrell, NFQ & UC3M
\begin_inset Newline newline
\end_inset


\family typewriter
guillemborrell@gmail.com
\begin_inset Newline newline
\end_inset

guillem.borrell@nfq.es
\end_layout

\begin_layout Abstract
Two years ago I was asked to develop a framework to ease the development
 of component-based distributed applications.
 This was a chance to take a look at the architecture trends and to analyze
 how to deal with complexity.
 We already know that complexity can be managed with more and better abstraction
s, but building abstractions is one of the most complex parts of programming.
 This article is an opinionated analysis of the patterns that tend to produce
 successful abstractions, and the path that lead to them.
 The most relevant conclusion is that, since abstraction layers are a way
 to communicate with others, it is almost impossible to ignore the social
 aspects of programming when dealing with them.
\end_layout

\begin_layout Section
A new generation of applications.
\end_layout

\begin_layout Subsection
A personal background.
\end_layout

\begin_layout Standard
About three years ago I was asked to take a look at the performance issues
 of some applications developed at NFQ Solutions.
 At that time, I was finishing a PhD on wall bounded turbulence, which is
 a completely different topic.
 However, such a long and hard thesis trained me well at applyind the Scientific
 Method, and allowed me to use very large supercomputers.
 This means that, before looking at the scalability issues of an enterprise
 application, I already had a solid theoretical idea of what works and what
 does not.
\end_layout

\begin_layout Standard
When I completed my PhD, I was asked to look closely at those performance
 and scalability issues, and to find a solution for them.
 The idea was to use a scientific approach, and to use bleeding edge technologie
s to design a new architecture for the next generation of applications at
 NFQ.
 We called that project PALM.
 The meaning of the acronym is not important.
 It was a research project at the beginning, with no guarantees that the
 outcome of my work would never be fully applied to appications deployed
 in production.
\end_layout

\begin_layout Standard
During my PhD I had to write small programs that were intented to solve
 a particular problem.
 The goal was to obtain an accurate result as fast as possible, and the
 time they spent running was seldom longer that it took to develop them.
 But I also had to implement very large parallel programs for supercomputers.
 They are completely different beasts.
 One of them has consumed hundreds of millions of CPU hours in supercomputers.
 Those large programs paid almost no attention to architecture, but a lot
 of effort went on performance optimization.
 If you spend six months developing but a simulation takes two years to
 complete, you run out resources.
 But if you spend one year developing, and the simulation takes one year
 to run, yo may make it.
 You may be surprised the amount of theses and papers published with half-cooked
 results.
 This is a useful example to understand that, in some particular cases cases,
 spending some time optimizing the application is a requirement.
 Now think about some enterprise applications that run for five years or
 a decade, or that are responsible to asses the financial risk of the full
 portfolio of a bank.
\end_layout

\begin_layout Standard
I had two years to learn about application architecture, which is quite
 a lot of time compared to the time you have to do some research in a middle-siz
ed companies.
 But architecture is a weird topic.
 It has a lot to do about technology, but there's also some craftmanship.
 In addition, when you ask an application architect for advice, they usually
 tell you to repeat what they have previously done.
 If you know a little about how the difference between correlation and causality
 affects your daily life, here you have one example.
 If you repeat a successful strategy, there is no guarantee that you will
 be successful again.
 On the other hand, following a strategy that has already failed most likely
 results in yet another failure.
 Architecture is a complex discipline that is also quite difficult to learn,
 unless you are willing to start doing things by yourself, and to learn
 by your own mistakes.
\end_layout

\begin_layout Standard
This is why I started pylm (http://pylm.readthedocs.org/), a small library
 to create components and to connect them.
 Pylm has been relatively successful.
 It will be put in production by NFQ sooner rather than later in a tool
 for asset liability management.
 Pylm, and other tools developed below the umbrella of the PALM project
 have significantly simplified the way our proprietry applications are built
 now.
 But apart from the final product of the process, which is the pylm library,
 there have been mistakes and good ideas too.
 
\end_layout

\begin_layout Subsection
Distributed applications and scalability.
\end_layout

\begin_layout Standard
Until roughly the beginning of this decade, most applications used the three-tie
r approach.
 Your application is divided between the presentation layer, the business
 layer, and finally, the data access layer.
 Now we all know that this architecture is not 
\emph on
Internet Scale
\emph default
, whatever that means.
 I have a different theory about why this architecture has been abandoned
 forever.
\end_layout

\begin_layout Standard
With time, applications become more and more complex.
 New data sources, new services, multiple databases, proxies, caches for
 performance.
 Layers have become more of a conceptual label than a functional division.
 We have now the frontend, that runs in the browser or on an app, and the
 backend.
 And the world has settled on the fact that the frontend and the backend
 talk to each other via a RESTful API.
\end_layout

\begin_layout Standard
I think that we forgot about the three-tier architecture because we realized
 that applications are quite organic, and as soon as you need extra performance
 layers start mixing up.
\end_layout

\begin_layout Standard
Another important change is that we no longer integrate libraries.
 Now we integrate third party components.
 I don't think that anyone would think nowadays to integrate Lucene to her
 database.
 Probably many of you haven't even heard about Lucene.
 She would dump her data to Elasticsearch, even if that means relying on
 a third party tool, or duplicating data.
 Now we even push traces and logs to third party components.
 Everyone is running on the cloud anyways, and technically the servers are
 already a third-party owned commodity.
\end_layout

\begin_layout Standard
When asking for architecture, all I got were yet another components, or
 message queue libraries.
\end_layout

\begin_layout Subsection
Connecting components
\end_layout

\begin_layout Standard
There is a little-known methodology in engineering called axiomatic design.
 I am an aerospatial engineer, and I know that there are quite a lot of
 methodologies besides waterfall and agile.
 Axiomatic design, like any other methodology, presents serious caveats,
 but they can offer some insight too.
 The real content of axiomatix design are its two axioms: the independence
 axiom, and the information axiom.
\end_layout

\begin_layout Standard
The former states that a good design maintains the independence between
 the functional requirements, and the latter says that a good design is
 the one that minimizes the information content of the design.
 Note that the two axioms are mutually exclusive in practice.
 If you go for maximum independence, you probably end up with too much pieces
 to implement a given functionality.
\end_layout

\begin_layout Standard
This new breed of distributed applications, regardless of the architectural
 paradigm one uses to build them, can be analyzed using these two axioms.
 We can say that a design that requires less components with a simpler API
 is less complex too.
 This is rather obvious, and my intention is to emphasize that these ideas
 are not mine at all.
 But the most important thing is that these axioms are useful to tell if
 our applications are well crafted, but give no advice about how to build
 them.
\end_layout

\begin_layout Section
Abstraction
\end_layout

\begin_layout Standard
This is probably a spoiler, but the way we deal with complexity is through
 abstraction.
 We pick a complex concept, we agree on the meaning of the concept, and
 then we assign a name to it.
 Now we can use this simbol, together with other symbols we agree on to
 build yet more symbols.
 This capability of dealing with symbols is probably what makes us unique
 within the animal kingdom, and we have become very good at it.
\end_layout

\begin_layout Standard
Computing has become successively simpler because we have put layers and
 layers of abstraction.
 We put pandas dataframes over numpy arrays over memory buffers over an
 interpreter coded in C that manages bytecode that is translated to machine
 language.
 Now we use dataframes like a 
\emph on
lingua franca
\emph default
 for data analyisis, because symbol that is most useful for peer-to-peer
 communication is the one with the highest level of abstraction.
 
\end_layout

\begin_layout Standard
We can apply the two axioms to determine the fitness of the abstractions
 the following way.
\end_layout

\begin_layout Standard
Table
\end_layout

\begin_layout Standard
We should always remind that the two axioms are mutually exclusive.
 If we try to be precise, we may end with a lexicon that is too extense,
 while brevity and jargon usuall drives to ambiguity.
\end_layout

\begin_layout Subsection
Effective abstractions and communication.
\end_layout

\begin_layout Standard
Building an API, an abstraction that has to be understood by someone else,
 requires certain skill.
 Some people are better than others at 
\emph on
explaining
\emph default
.
 And anyone has a different concept of 
\emph on
self-explanatory
\emph default
.
 We are undeniably the center of our world, but we are just one user, and
 things that are 
\emph on
self-explanatory 
\emph default
to us are not necessarily successful.
\end_layout

\begin_layout Standard
Abstractions get better the same way we get smarter.
 Talking to smart people.
 I've said that before, and the question I had immediately was, 
\begin_inset Quotes eld
\end_inset

what do I do if there isn't anyone smarter than me around?
\begin_inset Quotes erd
\end_inset

.
 Just talk to a frend.
 
\begin_inset Quotes eld
\end_inset

What do I do of I have no friends?
\begin_inset Quotes erd
\end_inset

.
 Well, there's a solution even in that case.
 
\end_layout

\begin_layout Standard
Abstractions require domain-specific knowledge, they are hard to get right,
 and in consequence they are seldom bikeshedded.
 
\end_layout

\begin_layout Standard
If a feature that has no user cannot be criticized.
 Don't write it.
 It may seem great to you, but most likely you will be overengineering your
 application.
 I know sometimes is hard to overcome the urge to add some cool feature.
 If noone asked for it, don't put it.
 PALM had
\end_layout

\begin_layout Subsection
Good abstractions are the ones giving meaning.
\end_layout

\begin_layout Standard
Sometimes you need two levels of abstraction.
 Carlos and his patch.
\end_layout

\begin_layout Subsection
Abstractions for survival.
\end_layout

\begin_layout Standard
People leaves, changes jobs.
 Javadoc vs Sphinx, remember that Kernighan and Ritchie wrote a BOOK.
 Do everything like you wanted to open source them.
 Write your own thing that matches your philosophy.
 Learn the lessons for other tools, but do not use them without serious
 reasons to do that.
\end_layout

\end_body
\end_document
